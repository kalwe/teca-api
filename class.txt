# constants.py
from datetime import timedelta

STANDARD_WORKDAY_HOURS = timedelta(hours=8)

# enums.py
from enum import Enum

class EmploymentStatus(Enum):
    """
    Enum to represent the employment status of an employee.
    """
    ACTIVE = "Active"
    ON_LEAVE = "On Leave"
    TERMINATED = "Terminated"


# base_entity.py
from tortoise import fields, models
from datetime import datetime
from typing import Type, TypeVar

T = TypeVar("T", bound="BaseEntity")

class BaseEntity(models.Model):
    """
    Abstract base model containing common fields and utility methods for other models.
    All models should inherit from this class to share the same base functionality.
    """
    id = fields.IntField(pk=True, description="Primary key for the record.")
    created_at = fields.DatetimeField(auto_now_add=True, description="Timestamp when the record was created.")
    updated_at = fields.DatetimeField(auto_now=True, description="Timestamp when the record was last updated.")
    is_active = fields.BooleanField(default=True, description="Indicates whether the record is active or not.")
    deleted_at = fields.DatetimeField(null=True, description="Timestamp when the record was soft-deleted.")
    version = fields.IntField(default=1, description="Version of the record for optimistic concurrency.")

    class Meta:
        abstract = True

    async def deactivate_record(self: T) -> T:
        """
        Soft deletes the record by setting 'is_active' to False and recording the deletion time.

        Args:
            self (T): The instance of the model.

        Returns:
            T: The instance of the model after deactivation.
        """
        self.is_active = False
        self.deleted_at = datetime.now()
        await self.save()
        return self

    async def restore_record(self: T) -> T:
        """
        Restores a soft-deleted record by setting 'is_active' to True and clearing 'deleted_at'.

        Args:
            self (T): The instance of the model.

        Returns:
            T: The instance of the model after restoration.
        """
        self.is_active = True
        self.deleted_at = None
        await self.save()
        return self

    def __str__(self: T) -> str:
        """
        String representation of the object.

        Returns:
            str: A string representation of the object, including its ID and active status.
        """
        return f"ID: {self.id}, Active: {self.is_active}"

    @classmethod
    async def get_active_records(cls: Type[T]) -> Type[T]:
        """
        Retrieves all active records of the model.

        Args:
            cls (Type[T]): The class of the model.

        Returns:
            Type[T]: A queryset of all active records.
        """
        return await cls.filter(is_active=True)

    @classmethod
    async def get_deleted_records(cls: Type[T]) -> Type[T]:
        """
        Retrieves all soft-deleted records of the model.

        Args:
            cls (Type[T]): The class of the model.

        Returns:
            Type[T]: A queryset of all soft-deleted records.
        """
        return await cls.filter(is_active=False)

    @classmethod
    async def soft_delete_record(cls: Type[T], record_id: int) -> Type[T]:
        """
        Soft deletes a record by its ID.

        Args:
            cls (Type[T]): The class of the model.
            record_id (int): The ID of the record to be soft deleted.

        Returns:
            Type[T]: The soft-deleted record.
        """
        record = await cls.get(id=record_id)
        await record.deactivate_record()
        return record


# access_control.py
from tortoise import fields
from typing import List, Type

from app.core.models.user import User

class PermissionStrategy:
    """
    Base strategy class for permissions.
    """
    def can_access(self, user: 'User', resource: str) -> bool:
        raise NotImplementedError("Each strategy must implement 'can_access'.")

class AdminPermissionStrategy(PermissionStrategy):
    """
    Permission strategy for Admin users.
    """
    def can_access(self, user: 'User', resource: str) -> bool:
        return True  # Admins can access any resource

class ManagerPermissionStrategy(PermissionStrategy):
    """
    Permission strategy for Manager users.
    """
    def can_access(self, user: 'User', resource: str) -> bool:
        allowed_resources = {"employee_records", "reports"}
        return resource in allowed_resources

class EmployeePermissionStrategy(PermissionStrategy):
    """
    Permission strategy for Employee users.
    """
    def can_access(self, user: 'User', resource: str) -> bool:
        return resource == "personal_records"

class AccessControl:
    """
    A class for managing access control based on user permissions.
    Uses the Strategy pattern to allow different permission strategies.
    """
    def __init__(self, permission_strategy: PermissionStrategy):
        self.permission_strategy = permission_strategy

    def set_permission_strategy(self, permission_strategy: PermissionStrategy) -> None:
        """
        Sets the permission strategy dynamically.
        """
        self.permission_strategy = permission_strategy

    def can_access(self, user: 'User', resource: str) -> bool:
        """
        Determines if the user has permission to access the given resource.
        """
        return self.permission_strategy.can_access(user, resource)


# active_employee.py
from tortoise import fields

from app.core.models.employee_related import EmployeeRelatedModel

class ActiveEmployee(EmployeeRelatedModel):
    """
    Model to represent active employees, encapsulating their active status.
    """
    contract_expiry_date = fields.DateField(null=True, description="Contract expiry date for the employee")
    is_currently_active = fields.BooleanField(
        default=True,
        description="Indicates if the employee is currently active or not"
    )

    def __str__(self):
        return f"{self.employee.full_name} is {'active' if self.is_currently_active else 'inactive'}"

# alert.py
from tortoise import fields
from typing import List, Protocol

from app.core.models.base_entity import BaseEntity

class Notifiable(Protocol):
    """
    A protocol for all notification services, allowing for extensibility.
    """
    def send_notification(self, message: str, recipient: str) -> None:
        """ Sends a notification to a given recipient """
        pass

class AlertEvent:
    """
    Represents an event (alert) to be triggered in the system.
    This event will be listened to by one or more notification services.
    """
    def __init__(self, alert_type: str, alert_message: str, recipient_email: str):
        self.alert_type = alert_type
        self.alert_message = alert_message
        self.recipient_email = recipient_email

    def __str__(self):
        return f"Alert for {self.alert_type} to {self.recipient_email}"


class Alert(BaseEntity):
    """
    Represents an alert to be sent to an employee, using an injectable notifier.
    """
    alert_type = fields.CharField(max_length=100, description="Type of alert (e.g., Birthday, Contract Expiry)")
    alert_message = fields.TextField(description="The content of the alert")
    recipient_email = fields.CharField(max_length=255, description="Email address of the recipient")

    def __str__(self):
        return f"Alert for {self.alert_type} to {self.recipient_email}"

    def trigger_event(self, event_emitter: 'EventEmitter') -> None:
        """
        Triggers the alert event to be handled by the event emitter (which notifies observers).
        """
        alert_event = AlertEvent(self.alert_type, self.alert_message, self.recipient_email)
        event_emitter.emit(alert_event)

class EventEmitter:
    """
    A class that emits events and notifies registered observers (notification services).
    Implements the 'Observer Pattern'.
    """
    def __init__(self):
        self._observers: List[Notifiable] = []

    def register_observer(self, observer: Notifiable) -> None:
        """
        Registers an observer (notification service) to listen for events.
        """
        self._observers.append(observer)

    def unregister_observer(self, observer: Notifiable) -> None:
        """
        Removes an observer from the list of listeners.
        """
        self._observers.remove(observer)

    def emit(self, event: AlertEvent) -> None:
        """
        Emits an event, notifying all registered observers (notification services).
        """
        for observer in self._observers:
            observer.send_notification(event.alert_message, event.recipient_email)

# contact_information.py
from tortoise import fields

from app.core.models.employee_related import EmployeeRelatedModel

class ContactInformation(EmployeeRelatedModel):
    """
    Model to store contact details of an employee.
    """
    phone_number = fields.CharField(
        max_length=15,
        description="Phone number"
    )
    email_address = fields.CharField(
        max_length=255,
        description="Email address"
    )
    physical_address = fields.TextField(
        description="Physical address"
    )

    def __str__(self):
        return f"Contact Information for {self.employee.full_name}"

# employee_documentation.py
from tortoise import fields

from app.core.models.employee_related import EmployeeRelatedModel

class EmployeeDocumentation(EmployeeRelatedModel):
    """
    Model for storing documentation related to an employee.
    """
    document_type = fields.CharField(
        max_length=100,
        description="Type of document (e.g., contract, certificate)"
    )
    document_path = fields.CharField(
        max_length=255,
        description="Path or URL to the document file"
    )

    def __str__(self):
        return f"{self.document_type} - {self.employee.full_name}"

# employee_related.py
from tortoise import fields

from app.core.models.base_entity import BaseEntity

class EmployeeRelatedModel(BaseEntity):
    """
    Abstract model for data related to an employee.
    """
    employee = fields.ForeignKeyField(
        "models.Employee",
        related_name="%(class)s_related",
        description="Reference to the associated employee"
    )

    class Meta:
        abstract = True

# employee_report.py

from tortoise import fields

from app.core.models.employee_related import EmployeeRelatedModel

class EmployeeReport(EmployeeRelatedModel):
    """
    Represents a time report for an employee within a specific period.
    """
    start_date = fields.DateField(
        description="Start date of the reporting period"
    )
    end_date = fields.DateField(
        description="End date of the reporting period"
    )
    total_worked_hours = fields.DecimalField(
        max_digits=5,
        decimal_places=2,
        default=0.0
    )
    total_overtime_hours = fields.DecimalField(
        max_digits=5,
        decimal_places=2,
        default=0.0
    )
    total_adjusted_hours = fields.DecimalField(
        max_digits=5,
        decimal_places=2,
        default=0.0
    )

    def __str__(self) -> str:
        return

# employee_status.py
from tortoise import fields

from app.core.models.employee_related import EmployeeRelatedModel
from app.core.models.enums import EmploymentStatus

class EmployeeStatus(EmployeeRelatedModel):
    """
    Model to manage the current status of an employee.
    """
    current_status = fields.CharEnumField(
        EmploymentStatus,
        description="Current employment status"
    )

    def __str__(self):
        return f"Status of {self.employee.full_name}: {self.current_status.value}"

# employee.py
from tortoise import fields

from app.core.models.person import PersonModel

class Employee(PersonModel):
    """
    Model representing an employee with personal details.
    """
    tax_id = fields.CharField(max_length=14, unique=True, description="Tax identification number (CPF)")
    national_id = fields.CharField(max_length=20, unique=True, description="National identification number (RG)")

    def __str__(self):
        return self.full_name

# employment_history.py
from tortoise import fields

from app.core.models.employee_related import EmployeeRelatedModel

class EmploymentHistory(EmployeeRelatedModel):
    """
    Model to record significant events and changes in an employee's employment.
    """
    change_description = fields.TextField(description="Description of the change or event")

    def __str__(self):
        return f"History for {self.employee.full_name} on {self.created_at.strftime('%Y-%m-%d %H:%M:%S')}"

# job_opening.py
from tortoise import fields

from app.core.models.base_entity import BaseEntity

class JobOpening(BaseEntity):
    """
    Model to represent a job opening within the company.
    """
    job_position = fields.CharField(
        max_length=255,
        description="The title of the job position that is currently open"
    )
    department_name = fields.CharField(
        max_length=100,
        description="The department where the job position is located"
    )
    available_positions = fields.IntField(
        description="The number of available positions for this job"
    )
    application_deadline = fields.DateField(
        description="The last date applicants can submit their applications"
    )

    def __str__(self):
        return f"Opening for {self.job_position} in {self.department_name}, {self.available_positions} positions"

# manual_adjustment.py
from tortoise import fields

from app.core.models.base_entity import BaseEntity

class ManualAdjustment(BaseEntity):
    """
    Represents a manual adjustment made by a manager on an employee's hours.
    """
    employee = fields.ForeignKeyField(
        "models.Employee",
        related_name="manual_adjustments"
    )
    adjusted_hours = fields.DecimalField(
        max_digits=5,
        decimal_places=2,
        description="Manually adjusted hours"
    )
    reason = fields.TextField(description="Justification for the adjustment")
    manager = fields.CharField(
        max_length=255,
        description="Manager responsible for the adjustment"
    )

    def __str__(self) -> str:
        return f"Manual Adjustment for {self.employee.full_name} ({self.adjusted_hours} hours) by {self.manager}"

# overtime.py
from typing import Protocol
from tortoise import fields

from app.core.models.employee_related import EmployeeRelatedModel

class OvertimeCalculationStrategy(Protocol):
    """
    A strategy interface to calculate overtime payment.
    """
    def calculate_overtime(self, hours: float, hourly_rate: float) -> float:
        """ Calculate the overtime payment """
        pass

class DefaultOvertimeStrategy(OvertimeCalculationStrategy):
    """
    Default strategy for overtime calculation.
    """
    def calculate_overtime(self, hours: float, hourly_rate: float) -> float:
        return hours * hourly_rate

class Overtime(EmployeeRelatedModel):
    """
    Model to store overtime worked by an employee,
    with flexible calculation strategies.
    """
    overtime_date = fields.DateField(
        description="Date of the overtime worked"
    )
    overtime_hours = fields.DecimalField(
        max_digits=5,
        decimal_places=2,
        description="Overtime hours worked"
    )
    department_name = fields.CharField(
        max_length=100,
        description="Department where overtime was worked"
    )
    hourly_rate = fields.DecimalField(
        max_digits=10,
        decimal_places=2,
        description="Hourly rate of the employee"
    )

    def calculate_overtime_payment(
        self,
        strategy: OvertimeCalculationStrategy) -> float:
        """
        Calculate overtime payment using a provided strategy.
        """
        return strategy.calculate_overtime(
            self.overtime_hours,
            self.hourly_rate
        )

    def __str__(self):
        return f"Overtime worked by {self.employee.full_name} on {self.overtime_date}"

# payroll_export_record.py
from tortoise import fields

from app.core.models.base_entity import BaseEntity

# TODO: verified is this class is necessary
class PayrollExportRecord(BaseEntity):
    """
    Represents the export of reports for payroll.
    """
    employee = fields.ForeignKeyField(
        "models.Employee",
        related_name="payroll_exports"
    )
    export_date = fields.DateField(
        description="Date of payroll export"
    )
    gross_salary = fields.DecimalField(
        max_digits=10,
        decimal_places=2,
        description="Total gross salary"
    )
    deductions = fields.DecimalField(
        max_digits=10,
        decimal_places=2,
        default=0.0,
        description="Total deductions"
    )
    net_salary = fields.DecimalField(
        max_digits=10,
        decimal_places=2,
        description="Net salary after deductions"
    )

    def __str__(self) -> str:
        return f"Payroll export for {self.employee.full_name} on {self.export_date}"

    @property
    def has_deductions(self) -> bool:
        """
        Indicates if there are any deductions.
        """
        return self.deductions > 0

# payroll_integration.py
from tortoise import fields

from app.core.models.base_entity import BaseEntity

# TODO: verify if this class is necessary
class PayrollIntegration(BaseEntity):
    """
    Represents the integration settings for the payroll system,
    such as API keys or URLs.
    """
    api_url = fields.CharField(
        max_length=255,
        description="API URL for payroll system integration"
    )
    api_key = fields.CharField(
        max_length=255,
        description="API key for accessing the payroll system"
    )

    def __str__(self):
        return f"Payroll integration with API at {self.api_url}"

# permission.py
from tortoise import fields

from app.core.models.base_entity import BaseEntity

class Permission(BaseEntity):
    """
    Represents a permission in the system
    (e.g., 'can_edit_employee', 'can_view_reports').

    Permissions define the actions that can be performed within the system.
    """
    name = fields.CharField(
        max_length=100,
        unique=True,
        description="The unique name of the permission."
    )
    description = fields.TextField(
        description="A detailed description of what the permission allows."
    )

    def __str__(self) -> str:
        """
        Returns the string representation of the Permission object.

        Returns:
            str: The name of the permission.
        """
        return self.name

# person.py
from tortoise import fields

from app.core.models.base_entity import BaseEntity

class PersonModel(BaseEntity):
    """
    Abstract model for person-related details.
    """
    full_name = fields.CharField(
        max_length=255,
        description="Full name of the person"
    )
    date_of_birth = fields.DateField(
        description="Date of birth of the person"
    )

    class Meta:
        abstract = True

# point_adjustment_history.py
from tortoise import fields

from app.core.models.employee_related import EmployeeRelatedModel

class PointAdjustmentHistory(EmployeeRelatedModel):
    """
    Represents the history of time adjustments made for an employee's point system.
    """
    reason = fields.CharField(
        max_length=255,
        description="Reason for the adjustment"
    )
    adjusted_hours = fields.DecimalField(
        max_digits=5,
        decimal_places=2,
        default=0.0, description="Adjusted hours"
    )
    adjustment_timestamp = fields.DatetimeField(
        description="Timestamp of the adjustment"
    )

    def __str__(self) -> str:
        return (
            f"Adjustment for {self.employee.full_name} on "
            f"{self.adjustment_timestamp.strftime('%Y-%m-%d %H:%M:%S')} "
            f"(Reason: {self.reason})"
        )

# professional_details.py
from tortoise import fields

from app.core.models.employee_related import EmployeeRelatedModel

class ProfessionalDetails(EmployeeRelatedModel):
    """
    Model for storing professional details of an employee.
    """
    job_title = fields.CharField(
        max_length=100,
        description="Job title of the employee"
    )
    department_name = fields.CharField(
        max_length=100,
        description="Name of the department"
    )
    employment_start_date = fields.DateField(
        description="Start date of employment"
    )
    current_salary = fields.DecimalField(
        max_digits=10,
        decimal_places=2,
        description="Current salary"
    )

    def __str__(self):
        return f"{self.job_title} - {self.employee.full_name}"

# recruitment_integration.py
from tortoise import fields

from app.core.models.base_entity import BaseEntity

class RecruitmentIntegration(BaseEntity):
    """
    Represents the integration settings for the recruitment system,
    such as API keys or URLs.
    """
    api_url = fields.CharField(
        max_length=255,
        description="API URL for recruitment system integration"
    )
    api_key = fields.CharField(
        max_length=255,
        description="API key for accessing the recruitment system"
    )

    def __str__(self):
        return f"Recruitment integration with API at {self.api_url}"

# report.py
from tortoise import fields

from app.core.models.base_entity import BaseEntity
from app.core.models.employee_related import EmployeeRelatedModel

class Report(EmployeeRelatedModel):
    """
    Represents a point report for an employee or a specific period.
    """
    start_date = fields.DateField()
    end_date = fields.DateField()
    total_hours = fields.DecimalField(
        max_digits=5,
        decimal_places=2,
        default=0.0
    )  # Total hours worked in the period
    total_overtime = fields.DecimalField(
        max_digits=5,
        decimal_places=2,
        default=0.0
    )  # Total overtime in the period
    total_adjustments = fields.DecimalField(
        max_digits=5,
        decimal_places=2,
        default=0.0
    )  # Total adjustments made

    def __str__(self):
        return f"Report for {self.employee.full_name} from {self.start_date} to {self.end_date}"

# role.py
from tortoise import fields

from app.core.models.base_entity import BaseEntity

class Role(BaseEntity):
    """
    Represents a role in the system, grouping a set of permissions (e.g., 'Admin', 'Manager').

    A role defines a collection of permissions that a user can have.
    """
    name = fields.CharField(
        max_length=100,
        unique=True,
        description="The unique name of the role."
    )
    permissions = fields.ManyToManyField(
        "models.Permission",
        related_name="roles",
        through="role_permissions",
        description="The permissions associated with the role."
    )

    def __str__(self) -> str:
        """
        Returns the string representation of the Role object.

        Returns:
            str: The name of the role.
        """
        return self.name

# time_bank_policy.py
from tortoise import fields

from app.core.models.base_entity import BaseEntity

class TimeBankPolicy(BaseEntity):
    """
    Represents the time bank policy, such as limits for using overtime
    or how compensations are calculated.
    """
    max_balance = fields.DecimalField(
        max_digits=10,
        decimal_places=2,
        description="Maximum balance in the time bank (in hours)"
    )
    allowed_usage_percentage = fields.FloatField(
        description="Percentage of time bank balance that can be used at once"
    )

    def __str__(self):
        return f"Max balance: {self.max_balance} hours, Allowed usage: {self.allowed_usage_percentage}%"

# time_bank_usage.py
from tortoise import fields
from typing import List, Protocol

from app.core.models.employee_related import EmployeeRelatedModel

class TimeBankObserver(Protocol):
    """ Observer interface for time bank changes. """
    def update(self, hours: float) -> None:
        """ Update method to be called when the time bank changes """
        pass

class TimeBank(EmployeeRelatedModel):
    """
    Model for recording and managing an employee's time bank usage.
    """
    hours_used = fields.DecimalField(
        max_digits=5,
        decimal_places=2,
        description="Hours used from the time bank"
        )
    remaining_balance = fields.DecimalField(
        max_digits=10,
        decimal_places=2,
        description="Remaining balance in the time bank"
        )
    usage_date = fields.DateField(description="Date of the time bank usage")

    observers: List[TimeBankObserver] = []

    def add_observer(self, observer: TimeBankObserver) -> None:
        """ Register an observer to be notified of changes """
        self.observers.append(observer)

    def remove_observer(self, observer: TimeBankObserver) -> None:
        """ Remove an observer """
        self.observers.remove(observer)

    def update_balance(self) -> None:
        """ Update the remaining balance and notify observers """
        self.remaining_balance -= self.hours_used
        self._notify_observers()

    def _notify_observers(self) -> None:
        """ Notify all observers about the change in balance """
        for observer in self.observers:
            observer.update(self.remaining_balance)

    def __str__(self):
        return f"Time bank usage for {self.employee.full_name} on {self.usage_date}"

# tolerance_policy.py
from tortoise import fields

from app.core.models.base_entity import BaseEntity

class TolerancePolicy(BaseEntity):
    """
    Represents the tolerance policy for delays and compensations.
    """
    max_delay = fields.IntField(
        description="Maximum allowed delay in minutes"
    )
    compensation_allowed = fields.BooleanField(
        default=True,
        description="Whether delay can be compensated"
    )

    def __str__(self):
        return f"Max delay: {self.max_delay} minutes, Compensation allowed: {self.compensation_allowed}"

# user.py
from tortoise import fields

from app.core.models.base_entity import BaseEntity

class User(BaseEntity):
    """
    Represents a user in the system, who can have one or more roles.

    A user can have one or more roles, each granting different permissions.
    """
    username = fields.CharField(
        max_length=100,
        unique=True,
        description="The unique username for the user."
    )
    email = fields.CharField(
        max_length=255,
        unique=True,
        description="The unique email address of the user."
        )
    password_hash = fields.CharField(
        max_length=255,
        description="The hashed password for the user."
    )
    roles = fields.ManyToManyField(
        "models.Role",
        related_name="users",
        through="user_roles",
        description="The roles assigned to the user."
    )

    def __str__(self) -> str:
        """
        Returns the string representation of the User object.

        Returns:
            str: The username of the user.
        """
        return self.username
