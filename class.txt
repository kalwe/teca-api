# constants.py
from datetime import timedelta

STANDARD_WORKDAY_HOURS = timedelta(hours=8)

# enums.py
from enum import Enum

class EmploymentStatus(Enum):
    """
    Enum to represent the employment status of an employee.
    """
    ACTIVE = "Active"
    ON_LEAVE = "On Leave"
    TERMINATED = "Terminated"


# base_entity.py
from tortoise import fields, models
from datetime import datetime
from typing import Type, TypeVar

T = TypeVar("T", bound="BaseEntity")

class BaseEntity(models.Model):
    """
    Abstract base model containing common fields and utility methods for other models.
    All models should inherit from this class to share the same base functionality.
    """
    id = fields.IntField(pk=True, description="Primary key for the record.")
    created_at = fields.DatetimeField(auto_now_add=True, description="Timestamp when the record was created.")
    updated_at = fields.DatetimeField(auto_now=True, description="Timestamp when the record was last updated.")
    is_active = fields.BooleanField(default=True, description="Indicates whether the record is active or not.")
    deleted_at = fields.DatetimeField(null=True, description="Timestamp when the record was soft-deleted.")
    version = fields.IntField(default=1, description="Version of the record for optimistic concurrency.")

    class Meta:
        abstract = True

    async def deactivate_record(self: T) -> T:
        """
        Soft deletes the record by setting 'is_active' to False and recording the deletion time.

        Args:
            self (T): The instance of the model.

        Returns:
            T: The instance of the model after deactivation.
        """
        self.is_active = False
        self.deleted_at = datetime.now()
        await self.save()
        return self

    async def restore_record(self: T) -> T:
        """
        Restores a soft-deleted record by setting 'is_active' to True and clearing 'deleted_at'.

        Args:
            self (T): The instance of the model.

        Returns:
            T: The instance of the model after restoration.
        """
        self.is_active = True
        self.deleted_at = None
        await self.save()
        return self

    def __str__(self: T) -> str:
        """
        String representation of the object.

        Returns:
            str: A string representation of the object, including its ID and active status.
        """
        return f"ID: {self.id}, Active: {self.is_active}"

    @classmethod
    async def get_active_records(cls: Type[T]) -> Type[T]:
        """
        Retrieves all active records of the model.

        Args:
            cls (Type[T]): The class of the model.

        Returns:
            Type[T]: A queryset of all active records.
        """
        return await cls.filter(is_active=True)

    @classmethod
    async def get_deleted_records(cls: Type[T]) -> Type[T]:
        """
        Retrieves all soft-deleted records of the model.

        Args:
            cls (Type[T]): The class of the model.

        Returns:
            Type[T]: A queryset of all soft-deleted records.
        """
        return await cls.filter(is_active=False)

    @classmethod
    async def soft_delete_record(cls: Type[T], record_id: int) -> Type[T]:
        """
        Soft deletes a record by its ID.

        Args:
            cls (Type[T]): The class of the model.
            record_id (int): The ID of the record to be soft deleted.

        Returns:
            Type[T]: The soft-deleted record.
        """
        record = await cls.get(id=record_id)
        await record.deactivate_record()
        return record


# active_employee.py
from tortoise import fields

from app.core.models.employee_related import EmployeeRelatedModel

class ActiveEmployee(EmployeeRelatedModel):
    """
    Model to represent active employees, encapsulating their active status.
    """
    contract_expiry_date = fields.DateField(null=True, description="Contract expiry date for the employee")
    is_currently_active = fields.BooleanField(
        default=True,
        description="Indicates if the employee is currently active or not"
    )

    def __str__(self):
        return f"{self.employee.full_name} is {'active' if self.is_currently_active else 'inactive'}"

# contact_information.py
from tortoise import fields

from app.core.models.employee_related import EmployeeRelatedModel

class ContactInformation(EmployeeRelatedModel):
    """
    Model to store contact details of an employee.
    """
    phone_number = fields.CharField(
        max_length=15,
        description="Phone number"
    )
    email_address = fields.CharField(
        max_length=255,
        description="Email address"
    )
    physical_address = fields.TextField(
        description="Physical address"
    )

    def __str__(self):
        return f"Contact Information for {self.employee.full_name}"

# employee_documentation.py
from tortoise import fields

from app.core.models.employee_related import EmployeeRelatedModel

class EmployeeDocumentation(EmployeeRelatedModel):
    """
    Model for storing documentation related to an employee.
    """
    document_type = fields.CharField(
        max_length=100,
        description="Type of document (e.g., contract, certificate)"
    )
    document_path = fields.CharField(
        max_length=255,
        description="Path or URL to the document file"
    )

    def __str__(self):
        return f"{self.document_type} - {self.employee.full_name}"

# employee_related.py
from tortoise import fields

from app.core.models.base_entity import BaseEntity

class EmployeeRelatedModel(BaseEntity):
    """
    Abstract model for data related to an employee.
    """
    employee = fields.ForeignKeyField(
        "models.Employee",
        related_name="%(class)s_related",
        description="Reference to the associated employee"
    )

    class Meta:
        abstract = True

# employee_report.py

from tortoise import fields

from app.core.models.employee_related import EmployeeRelatedModel

class EmployeeReport(EmployeeRelatedModel):
    """
    Represents a time report for an employee within a specific period.
    """
    start_date = fields.DateField(
        description="Start date of the reporting period"
    )
    end_date = fields.DateField(
        description="End date of the reporting period"
    )
    total_worked_hours = fields.DecimalField(
        max_digits=5,
        decimal_places=2,
        default=0.0
    )
    total_overtime_hours = fields.DecimalField(
        max_digits=5,
        decimal_places=2,
        default=0.0
    )
    total_adjusted_hours = fields.DecimalField(
        max_digits=5,
        decimal_places=2,
        default=0.0
    )

    def __str__(self) -> str:
        return

# employee_status.py
from tortoise import fields

from app.core.models.employee_related import EmployeeRelatedModel
from app.core.models.enums import EmploymentStatus

class EmployeeStatus(EmployeeRelatedModel):
    """
    Model to manage the current status of an employee.
    """
    current_status = fields.CharEnumField(
        EmploymentStatus,
        description="Current employment status"
    )

    def __str__(self):
        return f"Status of {self.employee.full_name}: {self.current_status.value}"

# employee.py
from tortoise import fields

from app.core.models.person import PersonModel

class Employee(PersonModel):
    """
    Model representing an employee with personal details.
    """
    tax_id = fields.CharField(max_length=14, unique=True, description="Tax identification number (CPF)")
    national_id = fields.CharField(max_length=20, unique=True, description="National identification number (RG)")

    def __str__(self):
        return self.full_name

# employment_history.py
from tortoise import fields

from app.core.models.employee_related import EmployeeRelatedModel

class EmploymentHistory(EmployeeRelatedModel):
    """
    Model to record significant events and changes in an employee's employment.
    """
    change_description = fields.TextField(description="Description of the change or event")

    def __str__(self):
        return f"History for {self.employee.full_name} on {self.created_at.strftime('%Y-%m-%d %H:%M:%S')}"
